[TOC]

# 第1 章　介绍

### 系统管理员模式 

test

### Google 的解决之道：SRE

### SRE 方法论

##### 	确保长期关注研发工作

#####     在保障服务SLO 的前提下最大化迭代速度

##### 	监控系统

#####     应急事件处理 

##### 	变更管理

##### 	需求预测和容量规划

##### 	资源部署

##### 	效率与性能

### 小结	



# 第2 章　Google 生产环境：SRE 视角

### 硬件   

### 管理物理服务器的系统管理软件   

##### 	管理物理服务器   

##### 	存储   

#####	网络   

### 其他系统软件   

##### 	分布式锁服务   

##### 	监控与警报系统   

### 软件基础设施   

### 研发环境   

### 莎士比亚搜索：一个示范服务   

##### 	用户请求的处理过程   

#####	任务和数据的组织方式  



# 第3 章　拥抱风险   

###管理风险   

###度量服务的风险   

### 服务的风险容忍度   

##### 	辨别消费者服务的风险容忍度   

##### 	基础设施服务的风险容忍度   

###使用错误预算的目的   

#####	错误预算的构建过程   

#####	好处   



#第4 章　服务质量目标  
###服务质量术语  
#####		指标  
#####		目标  
#####		协议  
###指标在实践中的应用  
#####	运维人员和最终用户各关心什么  
#####	指标的收集  
#####	汇总  
#####	指标的标准化  
###目标在实践中的应用  
#####目标的定义  
#####目标的选择  
#####控制手段  
#####SLO 可以建立用户预期  
###协议在实践中的应用  


#第5 章　减少琐事  

###琐事的定义  
###为什么琐事越少越好  
###什么算作工程工作  
###琐事繁多是不是一定不好  
###小结  
###第6 章　分布式系统的监控  
###术语定义  
###为什么要监控  
###对监控系统设置合理预期  
###现象与原因  
###黑盒监控与白盒监控  
###4 个黄金指标  
###关于长尾问题  
###度量指标时采用合适的精度  
###简化，直到不能再简化  
###将上述理念整合起来  
###监控系统的长期维护  
###Bigtable SRE ：警报过多的案例  
###Gmail ：可预知的、可脚本化的人工干预  
###长跑  
###小结  
###第7 章　Google 的自动化系统的演进  
###自动化的价值  
###一致性  
###平台性  
###修复速度更快  
###行动速度更快  
###节省时间  
###自动化对Google SRE 的价值  
###自动化的应用案例  
###Google SRE 的自动化使用案例  
###自动化分类的层次结构  
###让自己脱离工作：自动化所有的东西  
###舒缓疼痛：将自动化应用到集群上线中  
###使用Prodtest 检测不一致情况  
###幂等地解决不一致情况  
###专业化倾向  
###以服务为导向的集群上线流程  
###Borg ：仓库规模计算机的诞生  
###可靠性是最基本的功能  
###建议  
###第8 章　发布工程  
###发布工程师的角色  
###发布工程哲学  
###自服务模型  
###追求速度  
###密闭性  
###强调策略和流程  
###持续构建与部署  
###构建  
###分支  
###测试  
###打包  
###Rapid 系统  
###部署  
###配置管理  
###小结  
###不仅仅只对Google 有用  
###一开始就进行发布工程  
###第9 章　简单化  
###系统的稳定性与灵活性  
###乏味是一种美德  
###我绝对不放弃我的代码  
###“负代码行”作为一个指标  
###最小 API  
###模块化  
###发布的简单化  
###小结  
###第Ⅲ部分　具
###第10 章　基于时间序列数据进行有效报警  
###Borgmon 的起源  
###应用软件的监控埋点  
###监控指标的收集  
###时间序列数据的存储  
###标签与向量  
###Borg 规则计算  
###报警   
###监控系统的分片机制   
###黑盒监控   
###配置文件的维护   
###十年之后   
###第11 章　on-call 轮值   
###介绍   
###on-call 工程师的一天   
###on-call 工作平衡   
###数量上保持平衡   
###质量上保持平衡   
###补贴措施   
###安全感   
###避免运维压力过大   
###运维压力过大   
###奸诈的敌人—运维压力不够   
###小结   
###第12 章　有效的故障排查手段   
###理论   
###实践   
###故障报告   
###定位   
###检查   
###诊断   
###测试和修复   
###神奇的负面结果   
###治愈   
###案例分析   
###使故障排查更简单   
###小结   
###第13 章　紧急事件响应   
###当系统出现问题时怎么办   
###测试导致的紧急事故   
###细节   
###响应   
###事后总结   
###变更部署带来的紧急事故   
###细节   
###事故响应   
###事后总结   
###流程导致的严重事故   
###细节   
###灾难响应   
###事后总结   
###所有的问题都有解决方案   
###向过去学习，而不是重复它   
###为事故保留记录   
###提出那些大的，甚至不可能的问题：假如……   
###鼓励主动测试   
###小结   
###第14 章　紧急事故管理   
###无流程管理的紧急事故   
###对这次无流程管理的事故的剖析   
###过于关注技术问题   
###沟通不畅   
###不请自来   
###紧急事故的流程管理要素   
###嵌套式职责分离   
###控制中心   
###实时事故状态文档   
###明确公开的职责交接   
###一次流程管理良好的事故   
###什么时候对外宣布事故   
###小结   
###第15 章　事后总结：从失败中学习   
###Google 的事后总结哲学   
###协作和知识共享   
###建立事后总结文化   
###小结以及不断优化   
###第16 章　跟踪故障   
###Escalator   
###Outalator   
###聚合   
###加标签   
###分析   
###未预料到的好处   
###第17 章　测试可靠性   
###软件测试的类型   
###传统测试   
###生产测试   
###创造一个构建和测试环境   
###大规模测试   
###测试大规模使用的工具   
###针对灾难的测试   
###对速度的渴求   
###发布到生产环境   
###允许测试失败   
###集成   
###生产环境探针   
###小结   
###第18 章　SRE 部门中的软件工程实践   
###为什么软件工程项目对SRE 很重要   
###Auxon 案例分析：项目背景和要解决的问题   
###传统的容量规划方法   
###解决方案：基于意图的容量规划   
###基于意图的容量规划   
###表达产品意图的先导条件   
###Auxon 简介   
###需求和实现：成功和不足   
###提升了解程度，推进采用率   
###团队内部组成   
###在SRE 团队中培养软件工程风气   
###在SRE 团队中建立起软件工程氛围：招聘与开发时间   
###做到这一点   
###小结   
###第19 章　前端服务器的负载均衡   
###有时候硬件并不能解决问题   
###使用DNS 进行负载均衡   
###负载均衡：虚拟IP   
###第20 章　数据中心内部的负载均衡系统   
###理想情况   
###识别异常任务：流速控制和跛脚鸭任务   
###异常任务的简单应对办法：流速控制   
###一个可靠的识别异常任务的方法：跛脚鸭状态   
###利用划分子集限制连接池大小   
###选择合适的子集   
###子集选择算法一：随机选择   
###子集选择算法二：确定性算法   
###负载均衡策略   
###简单轮询算法   
###最闲轮询策略   
###加权轮询策略   
###第21 章　应对过载   
###QPS 陷阱   
###给每个用户设置限制   
###客户端侧的节流机制   
###重要性   
###资源利用率信号   
###处理过载错误   
###决定何时重试   
###连接造成的负载   
###小结   
###第22 章　处理连锁故障   
###连锁故障产生的原因和如何从设计上避免   
###服务器过载   
###资源耗尽   
###服务不可用   
###防止软件服务器过载   
###队列管理   
###流量抛弃和优雅降级   
###重试   
###请求延迟和截止时间   
###慢启动和冷缓存   
###保持调用栈永远向下   
###连锁故障的触发条件   
###进程崩溃   
###进程更新   
###新的发布   
###自然增长   
###计划中或计划外的不可用   
###连锁故障的测试   
###测试直到出现故障，还要继续测试   
###测试最常用的客户端   
###测试非关键性后端   
###解决连锁故障的立即步骤   
###增加资源   
###停止健康检查导致的任务死亡   
###重启软件服务器   
###丢弃流量   
###进入降级模式   
###消除批处理负载   
###消除有害的流量   
###小结   
###第23 章　管理关键状态：利用分布式共识来提高可靠性   
###使用共识系统的动力：分布式系统协调失败   
###案例1 ：脑裂问题   
###案例2 ：需要人工干预的灾备切换   
###案例3 ：有问题的小组成员算法   
###分布式共识是如何工作的   
###Paxos 概要：协议示例   
###分布式共识的系统架构模式   
###可靠的复制状态机   
###可靠的复制数据存储和配置存储   
###使用领头人选举机制实现高可用的处理系统   
###分布式协调和锁服务   
###可靠的分布式队列和消息传递   
###分布式共识系统的性能问题   
###复合式Paxos ：消息流过程详解   
###应对大量的读操作   
###法定租约   
###分布式共识系统的性能与网络延迟   
###快速Paxos 协议：性能优化   
###稳定的领头人机制   
###批处理   
###磁盘访问   
###分布式共识系统的部署   
###副本的数量   
###副本的位置   
###容量规划和负载均衡   
###对分布式共识系统的监控   
###小结   
###第24 章　分布式周期性任务系统   
###Cron   
###介绍   
###可靠性   
###Cron 任务和幂等性   
###大规模Cron 系统   
###对基础设施的扩展   
###对需求的扩展   
###Google Cron 系统的构建过程   
###跟踪Cron 任务的状态   
###Paxos 协议的使用   
###领头人角色和追随者角色   
###保存状态   
###运维大型Cron 系统   
###小结   
###第25 章　数据处理流水线   
###流水线设计模式的起源   
###简单流水线设计模式与大数据   
###周期性流水线模式的挑战   
###工作分发不均造成的问题   
###分布式环境中周期性数据流水线的缺点   
###监控周期性流水线的问题   
###惊群效应   
###摩尔负载模式   
###Google Workflow 简介   
###Workflow 是模型—视图—控制器（MVC）模式   
###Workflow 中的执行阶段   
###Workflow 正确性保障   
###保障业务的持续性   
###小结   
###第26 章　数据完整性：读写一致   
###数据完整性的强需求   
###提供超高的数据完整性的策略   
###备份与存档   
###云计算环境下的需求   
###保障数据完整性和可用性：Google SRE 的目标   
###数据完整性是手段，数据可用性是目标   
###交付一个恢复系统，而非备份系统   
###造成数据丢失的事故类型   
###维护数据完整性的深度和广度的困难之处   
###Google SRE 保障数据完整性的手段   
###24 种数据完整性的事故组合   
###第一层：软删除   
###第二层：备份和相关的恢复方法   
###额外一层：复制机制   
###1T vs. 1E ：存储更多数据没那么简单   
###第三层：早期预警   
###确保数据恢复策略可以正常工作   
###案例分析   
###Gmail—2011 年2 月：从GTape 上恢复数据（磁带）   
###Google Music—2012 年3 月：一次意外删除事故的检测过程   
###SRE 的基本理念在数据完整性上的应用   
###保持初学者的心态   
###信任但要验证   
###xxvi ｜
###不要一厢情愿   
###纵深防御   
###小结   
###第27 章　可靠地进行产品的大规模发布   
###发布协调工程师   
###发布协调工程师的角色   
###建立发布流程   
###发布检查列表   
###推动融合和简化   
###发布未知的产品   
###起草一个发布检查列表   
###架构与依赖   
###集成   
###容量规划   
###故障模式  
###客户端行为   
###流程与自动化   
###开发流程   
###外部依赖   
###发布计划   
###可靠发布所需要的方法论   
###灰度和阶段性发布   
###功能开关框架   
###应对客户端滥用行为   
###过载行为和压力测试   
###LCE 的发展   
###LCE 检查列表的变迁   
###LCE 没有解决的问题   
###小结   
###第Ⅳ部分
###第28 章　迅速培养SRE 加入on-call   
###新的SRE 已经招聘到了，接下来怎么办   
###培训初期：重体系，而非混乱   
###系统性、累积型的学习方式   
###目标性强的项目工作，而非琐事   
###培养反向工程能力和随机应变能力   
###反向工程：弄明白系统如何工作   
###统计学和比较性思维：在压力下坚持科学方法论   
###随机应变的能力：当意料之外的事情发生时怎么办   
###将知识串联起来：反向工程某个生产环境服务   
###有抱负的on-call 工程师的5 个特点   
###对事故的渴望：事后总结的阅读和书写   
###故障处理分角色演习   
###破坏真的东西，并且修复它们   
###维护文档是学徒任务的一部分   
###尽早、尽快见习on-call   
###on-call 之后：通过培训的仪式感，以及日后的持续教育   
###小结   
###第29 章　处理中断性任务   
###管理运维负载   
###如何决策对中断性任务的处理策略   
###不完美的机器   
###流状态   
###将一件事情做好   
###实际一点的建议   
###减少中断   
###第30 章　通过嵌入SRE 的方式帮助团队从运维过载中恢复   
###第一阶段：了解服务，了解上下文   
###确定最大的压力来源   
###找到导火索   
###第二阶段：分享背景知识   
###书写一个好的事后总结作为示范   
###将紧急事件按类型排序   
###第三阶段：主导改变   
###从基础开始   
###获取团队成员的帮助   
###解释你的逻辑推理过程   
###提出引导性问题   
###小结   
###第 31 章　SRE 与其他团队的沟通与协作   
###沟通：生产会议   
###议程   
###出席人员   
###SRE 的内部协作   
###团队构成   
###高效工作的技术   
###SRE 内部的协作案例分析：Viceroy   
###Viceroy 的诞生   
###所面临的挑战   
###建议   
###SRE 与其他部门之间的协作   
###案例分析：将DFP 迁移到F1   
###小结   
###第32 章　SRE 参与模式的演进历程   
###SRE 参与模式：是什么、怎么样以及为什么   
###PRR 模型   
###SRE 参与模型   
###替代性支持   
###PRR ：简单PRR 模型   
###参与   
###分析   
###改进和重构   
###培训   
###“接手”服务   
###持续改进   
###简单PRR 模型的演进：早期参与模型   
###早期参与模型的适用对象   
###早期参与模型的优势   
###不断发展的服务：框架和SRE 平台   
###经验教训   
###影响SRE 的外部因素   
###结构化的解决方案：框架   
###新服务和管理优势   
###小结   
###第Ⅴ部分　
###第33 章　其他行业的实践经验   
###有其他行业背景的资深SRE   
###灾难预案与演习   
###从组织架构层面坚持不懈地对安全进行关注   
###关注任何细节   
###冗余容量   
###模拟以及进行线上灾难演习   
###培训与考核   
###对详细的需求收集和系统设计的关注   
###纵深防御   
###事后总结的文化   
###将重复性工作自动化，消除运维负载   
###结构化和理性的决策   
###小结   
###第34 章　结语   
###附录A　系统可用性   
###附录B　生产环境运维过程中的最佳实践   
###附录C　事故状态文档示范   
###附录D　事后总结示范   
###附录E　发布协调检查列表   
###附录F　生产环境会议记录示范   
###参考文献   
###索引   

